'''
A temporary solution without LL* parser.

For testing another cheap way of deserialize JSON in python, without Antlr4,
unless the stream mode is critical.

- Semantics consistence with Java is to be verified.

- No need for generating Python3 source code from JSON ?

'''
# https://colab.research.google.com/drive/1pqeZGfqdEl_kOlJQ76SCeuKTtD3NGlev
import json
from dataclasses import dataclass, field, fields, MISSING
from typing import Any, TypeVar

TAnson = TypeVar('TAnson', bound='Anson')


@dataclass
class Anson(dict):
    ''''
    Tests:
    class Anson(object):
        def __setitem__(self, key, value):
            self.__dict__[key] = value

        def __getitem__(self, item):
            return self.__dict__[item]

        def print(self):
            for k in self.__dict__:
                print(f"{k}: {self[k]}")

    from attr import dataclass
    @dataclass
    class Anson1(Anson):
        x: str = None

    a1 = Anson1()
    a1.x = 5
    print(a1)
    Anson1(x=5)
    a1.print()
    x: 5
    a1.v = "xxxx"
    a1.print()
    x: 5
    v: xxxx
    print(a1)
    Anson1(x=5)
    a1.t = "tttt"
    print(a1)
    Anson1(x=5)
    a1.print()
    x: 5
    v: xxxx
    t: tttt
    '''

    def __init__(self):
        super().__init__()
        self.__type__ = type(self)

    def __setitem__(self, key, value):
        self.__dict__[key] = value

    def __getitem__(self, key):
        return self.__dict__[key]

    def getFields(self):
        pass

    def toBlock(self):
        fields = self.getFields()
        s = '{'
        for k in self.__dict__:
            s += f'"{k}": '
            s += f'"{self[k]}"' if isinstance(self[k], str)\
                else self.toBlock() if isinstance(self[k], __dict__[k])\
                else str(self[k])
            s += ',\n'
        return s + '}'

    @staticmethod
    def from_obj(obj: dict) -> TAnson:
        anson = Anson()
        for k in obj:
            anson[k] = obj[k]
        return anson

    @staticmethod
    def from_json(jsonstr: str) -> TAnson:
        obj = json.loads(jsonstr)
        return Anson.from_obj(obj)

    def meta(self):
      return self.__type__


@dataclass
class ExtraData(Anson):
    s: str = None
    i: int = 0
    l: list = field(default_factory=list)
    d: dict = field(default_factory=dict)

@dataclass
class MyDataClass(Anson):
    name: str
    age: int
    extra: ExtraData
    items: list[Any] = field(default_factory=list)

    def __init__(self, name: str, age: str):
      self.extra = ExtraData()
      super().__init__()
      self.name = name
      self.age = age
 

foo = MyDataClass('Trump', 78)
trumpfields = fields(type(foo))
print(trumpfields)

# Get all fields of the dataclass
all_fields = fields(MyDataClass)
print(all_fields)

all_fields = trumpfields

# Iterate through the fields and print their names and types
for field_info in all_fields:
    print(f"Field Name: {field_info.name}, Field Type: {field_info.type}")

# Get the type of a specific field by name
age_field = next((f for f in all_fields if f.name == 'age'), None)
if age_field:
    print(f"The type of 'age' field is: {age_field.type}")

field_dict = {it.name: (it.name, it.type,
                        'class' if isinstance(it.type, str) else 'Anson' if issubclass(it.type, Anson) else 'na',
                        it.default_factory,
                        it.default_factory is MISSING) for it in all_fields}
print(f"------- {field_dict}")

my = MyDataClass('zz', 12)

print(f"type: {type(my)}\nmeta: {my.meta()}, my.age: {my['age']}")

mytype = type(my)
your = mytype('yy', 13)
fitem = field_dict['items']
your[fitem[0]] = fitem[3](['a', 'b'])
print(your)

'''
Field Name: name, Field Type: <class 'str'>
Field Name: age, Field Type: <class 'int'>
Field Name: extra, Field Type: <class '__main__.ExtraData'>
Field Name: items, Field Type: list[typing.Any]
The type of 'age' field is: <class 'int'>
------- {'name': ('name', <class 'str'>, 'na', <dataclasses._MISSING_TYPE object at 0x796ec92cb590>, True), 'age': ('age', <class 'int'>, 'na', <dataclasses._MISSING_TYPE object at 0x796ec92cb590>, True), 'extra': ('extra', <class '__main__.ExtraData'>, 'Anson', <dataclasses._MISSING_TYPE object at 0x796ec92cb590>, True), 'items': ('items', list[typing.Any], 'na', <class 'list'>, False)}
type: <class '__main__.MyDataClass'>
meta: <class '__main__.MyDataClass'>, my.age: 12
MyDataClass(name='yy', age=13, extra=ExtraData(s=None, i=0, l=[], d={}), items=['a', 'b'])
'''